% Initial guesses
u_initial_matrix = [1 1 pi/3 1; 0.5 0.5 pi/3-0.01 0.5; -1 -1 -pi/3 -1];
u_result_matrix = zeros(size(u_initial_matrix));
constants = [1 1 2 1; 1 1 1 10; 1 2 1 1];

% To calculate the order of convergence 
error_u_1 = zeros(25, 4);
error_u_2 = zeros(25, 4);
error_u_3 = zeros(25, 4);

for i = 1:4
u_vector = u_initial_matrix(:,i);
constant_vector = constants(:,i);

error_u_1(1:i) = u_initial_matrix(1:i);
error_u_2(1:i) = u_initial_matrix(1:i);
error_u_3(1:i) = u_initial_matrix(1:i);

% The Jacobian Matrix
J = jac_matrix(u_vector, constant_vector);

% Vector with the results from the three functions
func_vector = function_vector_matrix(u_vector, constant_vector);

% J\func_vector is the same as inv_jacobian * function_vector
d_variabler = J\func_vector;
u_next_vector = u_vector - d_variabler;

counter = 1;

while max(abs(d_variabler)) > 1e-10
    counter = counter + 1;
    u_vector = u_next_vector;
    
    if counter < 2
        error_u_1(counter:i) = u_vector(1);
        error_u_2(counter:i) = u_vector(2);
        error_u_3(counter:i) = u_vector(3);  
    end
    
    J = jac_matrix(u_vector, constant_vector);
    
    func_vector = function_vector_matrix(u_vector, constant_vector);
    
    d_variabler = J\func_vector;
    u_next_vector = u_vector - d_variabler;
end

u_vector = u_next_vector;
u_1 = u_vector(1);
u_2 = u_vector(2);
u_3 = u_vector(3);

u_result_matrix(1,i) = u_1;
u_result_matrix(2,i) = u_2;
u_result_matrix(3,i) = u_3;


Ax = 0;
Ay = 0;
Bx = 2;
By = 0;
m1x = cos(abs(u_1)); 
m1y = -sin(abs(u_1));
m2x = Bx - constant_vector(1)*cos(abs(u_3));
m2y = By - constant_vector(1)*sin(abs(u_3));

x = [Ax m1x m2x Bx Ax];
y = [Ay m1y m2y By Ay];
figure(i);
plot(x, y);


end
u_result_matrix